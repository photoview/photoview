directive @isAuthorized on FIELD_DEFINITION
directive @isAdmin on FIELD_DEFINITION

scalar Time
scalar Any

"Used to specify which order to sort items in"
enum OrderDirection {
  "Sort accending A-Z"
  ASC
  "Sort decending Z-A"
  DESC
}

"Used to specify pagination on a list of items"
input Pagination {
  "How many items to maximally fetch"
  limit: Int
  "How many items to skip from the beginning of the query, specified by the `Ordering`"
  offset: Int
}

"Used to specify how to sort items"
input Ordering {
  "A column in the database to order by"
  order_by: String
  order_direction: OrderDirection
}

"Credentials used to identify and authenticate a share token"
input ShareTokenCredentials {
  token: String!
  password: String
}

type Query {
  siteInfo: SiteInfo!

  "List of registered users, must be admin to call"
  user(order: Ordering, paginate: Pagination): [User!]! @isAdmin
  "Information about the currently logged in user"
  myUser: User! @isAuthorized

  "User preferences for the logged in user"
  myUserPreferences: UserPreferences! @isAuthorized

  """
  Get a list of media, ordered first by day, then by album if multiple media was found for the same day.
  """
  myTimeline(
    paginate: Pagination,
    onlyFavorites: Boolean,
    "Only fetch media that is older than this date"
    fromDate: Time
  ): [Media!]! @isAuthorized

  "Fetch a share token containing an `Album` or `Media`"
  shareToken(credentials: ShareTokenCredentials!): ShareToken!
  "Check if the `ShareToken` credentials are valid"
  shareTokenValidatePassword(credentials: ShareTokenCredentials!): Boolean!

  "Perform a search query on the contents of the media library"
  search(query: String!, limitMedia: Int, limitAlbums: Int): SearchResult!
}

type Mutation {
  "Authorizes a user and returns a token used to identify the new session"
  authorizeUser(username: String!, password: String!): AuthorizeResult!

  "Registers the initial user, can only be called if initialSetup from SiteInfo is true"
  initialSetupWizard(
    username: String!
    password: String!
    rootPath: String!
  ): AuthorizeResult

  "Scan all users for new media"
  scanAll: ScannerResult! @isAdmin
  "Scan a single user for new media"
  scanUser(userId: ID!): ScannerResult! @isAdmin

  "Generate share token for album"
  shareAlbum(albumId: ID!, expire: Time, password: String): ShareToken! @isAuthorized
  "Generate share token for media"
  shareMedia(mediaId: ID!, expire: Time, password: String): ShareToken! @isAuthorized
  "Delete a share token by it's token value"
  deleteShareToken(token: String!): ShareToken! @isAuthorized
  "Set a password for a token, if null is passed for the password argument, the password will be cleared"
  protectShareToken(token: String!, password: String): ShareToken! @isAuthorized

  "Update a user, fields left as `null` will not be changed"
  updateUser(
    id: ID!
    username: String
    password: String
    admin: Boolean
  ): User! @isAdmin
  "Create a new user"
  createUser(
    username: String!
    password: String
    admin: Boolean!
  ): User! @isAdmin
  "Delete an existing user"
  deleteUser(id: ID!): User! @isAdmin

  "Add a root path from where to look for media for the given user, specified by their user id."
  userAddRootPath(id: ID!, rootPath: String!): Album @isAdmin
  """
  Remove a root path from a user, specified by the id of the user and the top album representing the root path.
  This album was returned when creating the path using `userAddRootPath`.
  A list of root paths for a particular user can be retrived from the `User.rootAlbums` path.
  """
  userRemoveRootAlbum(userId: ID!, albumId: ID!): Album @isAdmin

  """
  Set how often, in seconds, the server should automatically scan for new media,
  a value of 0 will disable periodic scans
  """
  setPeriodicScanInterval(interval: Int!): Int! @isAdmin

  "Set max number of concurrent scanner jobs running at once"
  setScannerConcurrentWorkers(workers: Int!): Int! @isAdmin

  "Set the filter to be used when generating thumbnails"
  setThumbnailDownsampleMethod(method: ThumbnailFilter!): ThumbnailFilter! @isAdmin

  "Change user preferences for the logged in user"
  changeUserPreferences(language: String): UserPreferences! @isAuthorized
}

type Subscription {
  notification: Notification!
}

"Specified the type a particular notification is of"
enum NotificationType {
  "A regular message with no special additions"
  Message
  "A notification with an attached progress indicator"
  Progress
  "Close a notification with a given key"
  Close
}

type Notification {
  "A key used to identify the notification, new notification updates with the same key, should replace the old notifications"
  key: String!
  type: NotificationType!
  "The text for the title of the notification"
  header: String!
  "The text for the body of the notification"
  content: String!
  "A value between 0 and 1 when the notification type is `Progress`"
  progress: Float
  "Whether or not the message of the notification is positive, the UI might reflect this with a green color"
  positive: Boolean!
  "Whether or not the message of the notification is negative, the UI might reflect this with a red color"
  negative: Boolean!
  "Time in milliseconds before the notification should close"
  timeout: Int
}

type AuthorizeResult {
  success: Boolean!
  "A textual status message describing the result, can be used to show an error message when `success` is false"
  status: String!
  "An access token used to authenticate new API requests as the newly authorized user. Is present when success is true"
  token: String
}

type ScannerResult {
  finished: Boolean!
  success: Boolean!
  progress: Float
  message: String
}

"A token used to publicly access an album or media"
type ShareToken {
  id: ID!
  token: String!
  "The user who created the token"
  owner: User!
  "Optional expire date"
  expire: Time
  "Whether or not a password is needed to access the share"
  hasPassword: Boolean!

  "The album this token shares"
  album: Album
  "The media this token shares"
  media: Media
}

"Supported downsampling filters for thumbnail generation"
enum ThumbnailFilter {
  NearestNeighbor,
  Box,
	Linear,
	MitchellNetravali,
	CatmullRom,
	Lanczos,
}

"General information about the site"
type SiteInfo {
  "Whether or not the initial setup wizard should be shown"
  initialSetup: Boolean!
  "Whether or not face detection is enabled and working"
  faceDetectionEnabled: Boolean!
  "How often automatic scans should be initiated in seconds"
  periodicScanInterval: Int! @isAdmin
  "How many max concurrent scanner jobs that should run at once"
  concurrentWorkers: Int! @isAdmin
  "The filter to use when generating thumbnails"
  thumbnailMethod: ThumbnailFilter! @isAdmin
}

type User {
  id: ID!
  username: String!
  "All albums owned by this user"
  albums: [Album!]! @isAdmin
  "Top level albums owned by this user"
  rootAlbums: [Album!]! @isAdmin
  "Whether or not the user has admin privileges"
  admin: Boolean!
}

"Supported language translations of the user interface"
enum LanguageTranslation {
  English,
  French,
  Italian,
  Swedish,
  Danish,
  Spanish,
  Polish,
  Ukrainian,
  German,
  Russian,
  TraditionalChinese,
  SimplifiedChinese,
  Portuguese,
  Basque,
  Turkish
}

"Preferences for regular users"
type UserPreferences {
  id: ID!
  language: LanguageTranslation
}

type Coordinates {
  "GPS latitude in degrees"
  latitude: Float!
  "GPS longitude in degrees"
  longitude: Float!
}

"Metadata specific to video media"
type VideoMetadata {
  id: ID!
  media: Media!
  width: Int!
  height: Int!
  duration: Float!
  codec: String
  framerate: Float
  bitrate: String
  colorProfile: String
  audio: String
}

type SearchResult {
  "The string that was searched for"
  query: String!
  "A list of albums that matched the query"
  albums: [Album!]!
  "A list of media that matched the query"
  media: [Media!]!
}

"A group of media from the same album and the same day, that is grouped together in a timeline view"
type TimelineGroup {
  "The full album containing the media in this timeline group"
  album: Album!
  "The media contained in this timeline group"
  media: [Media!]!
  "The total amount of media in this timeline group"
  mediaTotal: Int!
  "The day shared for all media in this timeline group"
  date: Time!
}
